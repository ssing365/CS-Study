### 소스코드와 명령어

- 고급언어 : 사람이 이해하고 작성하기 쉽게 만들어진 언어
- 저급언어 : 컴퓨터가 이해하는 언어
    - 기계어 : 0과 1의 명령어 비트로 이루어진 언어
    - 어셈블리어 : 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

- 컴파일 언어
    - **컴파일 :** 고급언어(소스코드) → 저급언어(목적코드)
    - 소스코드에 오류가 하나라도 있다면 컴파일 불가

- 인터프리터 언어
    - 소스코드를 한줄 한줄 실행
    - 컴파일 언어보다 조금 느림
    - N번째 줄에 오류가 있어도 N-1번째 줄까지는 실행됨

<aside>

C언어 : 컴파일 언어

자바 : 컴파일 + 인터프리터 혼합

파이썬 : 인터프리터 언어

</aside>

### 명령어의 구조

**연산코드 + 오퍼랜드** 

- 연산코드
    
    : 명령어가 수행할 연산
    
    1. 데이터 전송
    2. 산술/논리 연산
    3. 제어 흐름 변경
    4. 입출력 제어
- 오퍼랜드
    
    : 연산에 사용할 데이터 혹은 데이터의 주소
    
    - 주소를 훨씬더 많이 쓰기 때문에 오퍼랜드 부분을 주소필드라고도 한다.
        - 오퍼랜드의 개수에 따라 명령어를 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어라고도 한다.

- 주소 지정 방식
    
    : 유효주소(연산할 데이터 위치)를 찾는 방법
    
    1. 즉시 주소 지정 방식
        - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하느 방식
        - 표현할 수 있는 데이터의 크기가 작아지지만, 빠름
    2. 직접 주소 지정 방식
        - 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
    3. 간접 주소 지정 방식
        - 유효주소의 주소를 오퍼랜드 필드에 명시
        - 표현할 수 있는 유효 주소의 범위가 넓어짐
        - 두번의 메모리 접근이 필요해 느리다.
    4. 레지스터 주소 지정 방식
        - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드에 명시
    5. **레지스터 간접 주소 지정 방식**
        - 연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
        - 메모리 접근 보다 레지스터 접근이 빠름
    
    <aside>
    
    C언어가 소스코드에서 실행파일이 되는 과정
    
    1. 전처리 과정(import 등 컴파일 준비)
    2. **컴파일** : 컴파일을 통해 어셈블리어로 변환
    3. **어셈블** : 어셈블리어  → 기계어(바이너리 코드) `.o`
    4. **링킹** : 여러 개의 오브젝트 파일(`.o`)과 라이브러리를 결합하여 실행 가능한 프로그램을 생성.
    5. 실행
    - 생성된 실행파일을 운영체제가 로드하고 CPU가 실행.
    - 메모리 할당 및 실행 환경을 설정한 후 프로그램 시작.
    
    </aside>