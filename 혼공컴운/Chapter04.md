### ALU와 제어장치

### ALU(계산기)

- 받아들이는 정보
    - 피연산자 ← from 레지스터
    - 제어신호 ← from 제어장치
- 내보내는 정보
    - 플래그 → to 플래그 레지스터
        - 플래그 : 연산 결과에 대한 추가적인 상태 정보
            - 부호 플래그
                
                 : 연산 결과의 부호(1 음수, 0 양수)
                
            - 제로 플래그
                
                : 연산 결과가 0인지 (1이면 0)
                
            - 캐리 플래그
                
                : 연산결과 올림수나 빌림수가 발생했는지 (1이면 발생)
                
            - 오버플로우 플래그
                
                : 오버플로우(결과가 너무 큼)가 발생했는지 (1이면 발생했음)
                
            - 인터럽트 플래그
                
                : 인터럽트가 가능한지 (1이면 가능함)
                
            - 슈퍼바이저 플래그
                
                : 커널모드로 실행중인지
                
                (1이면 커널모드로 실행중, 0이면 사용자모드로 실행중. 9장에서 학습)
                
    - 결괏값 → to 레지스터

### 제어장치

- 받아들이는 정보
    - 클럭
        
        : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
        
    - 해석할 명령어 ←from 명령어 레지스터
    - 플래그 ← from 플래그 레지스터
    - 제어신호 (외부에서도 얼마든지 제어신호를 발생할 수 있다)
- 내보내는 정보
    - 제어신호
        - → CPU 내부
            - to ALU
            - to 레지스터
        - → CPU 외부
            - to 메모리
            - to 입출력장치

### 레지스터

- 복습
    - 유효주소 : 연산에 사용할 데이터가 저장된 위치
    - 주소 지정 방식 : 연산에 사용할 데이터의 위치를 찾는 방식

---

## 꼭 알아야 할 8가지 레지스터

1. 프로그램 카운터
    
    : 메모리에서 가져올 명령어의 주소(메모리에서 읽어들일 명령어의 주소)
    
2. 메모리 주소 레지스터
    
    : 메모리의 주소를 저장
    
3. 메모리 버퍼 레지스터
    
    : 메모리와 주고받을 값(데이터와 명령어)을 저장
    
4. 명령어 레지스터
    
    : 해석할 명령어(방금 메모리에서 읽어 들인 명령어)
    
- 1~4번 레지스터를 거치는 cpu의 작동순서를 생각해보기
    - 프로그램 카운터는 프로그램 실행 첫번째 명령어 주소를 저장
    - 주소 버스를 통해 명령어 가져오기 위해 메모리 주소 레지스터 이용
    - 제어장치와 메모리주소 레지스터가 명령어를 가져오고, 그 명령어를 메모리 버퍼 레지스터에 저장
    - 프로그램 카운터 증가
        - 일반적으로 순차 증가하지만, JUMP명령어나 인터럽트 발생시 예외
    - 명령어 레지스터를 통해 실행

---

1. 플래그 레지스터
    
    : CPU상태나 연산결과의 부가 정보. 
    
2. 범용 레지스터
    
    : 다양하고 일반적인 상황에서 자유롭게 사용
    

---

### 특정 레지스터를 이용한 주소 지정 방식(1) : 스택 주소 지정 방식

1. 스택 포인터
    
    : 스택의 top 주소를 담고 있음
    

### 특정 레지스터를 이용한 주소 지정 방식(2) : 변위 주소 지정 방식

1. 베이스 레지스터
    
    : 기준 주소 저장
    
- 상대 주소 지정 방식 ⇒ 프로그램 카운터  + 오퍼랜드의 값
    - ex) 유효주소가 1003번지라면
        - 프로그램 카운터 1000, 오퍼랜드에 3
- 베이스 레지스터 주소 지정 방식 ⇒ 오퍼랜드 + 베이스 레지스터 값
    - ex) 유효주소가 2500번지라면
        - 베이스 레지스터 2000, 오퍼랜드 500

### 명령어 사이클과 인터럽트

### 명령어 사이클

- 프로그램은 수많은 명령어로 이루어져 있고, CPU는 명령어를 하나씩 실행한다.
- 프로그램 속 각 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 **명령어 사이클**이라고 한다.

<aside>
☝

구성

- 인출 사이클
    - 메모리에 있는 명령어를 CPU에 가져오는 과정
- 실행 사이클
    - CPU로 가져온 명령어를 실행하는 단계.
        - 레지스터 해석, 제어신호 발생
- 간접 사이클
    - 간접 주소 지정 방식 처럼 유효주소를 찾기 위해 한 번 더 메모리 접근 하는 단계
- 인터럽트
</aside>

### 인터럽트

- 동기 인터럽트**(예외)**
    - CPU에 의해 발생하는 인터럽트
        - CPU가 명령어를 수행하다 예상치 못한 상황에 마주쳤을때
        - 프로그래밍상의 오류 같이 예외적인 상황
- 비동기 인터럽트**(하드웨어 인터럽트)**
    - 주로 입출력장치에 의해 발생
        - 사용 이유
            - 입출력장치는 CPU에 비해 속도가 현저히 느리다.
            - 하드웨어 인터럽트(입출력 장치의 알림)가 없다면 CPU는 입출력 장치의 진행 상황을 주기적으로 확인해야한다.
            - 하드웨어 인터럽트 덕분에 CPU는 다른 일을 수행하고 있을 수 있어, 명령어를 효율적으로 처리할 수 있다.
    - CPU의 비동기 인터럽트 처리 순서
        1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
        2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
        3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
            - 중단할 수 없는 작업이면 인터럽트 플래그가 불가능으로 표시, 하던 일을 계속 한다.
            - 다만 하드웨어 고장 같은 플래그로 막을 수 없는 인터럽트도 있다.
        4. 인터럽트를 받아들일 수 있다면 지금까지의 작업을 백업한다.
            - 지금까지의 작업(현재 레지스터에 들어있는 값들)은 스택 영역에 백업한다.
        5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
            - 인터럽트 벡터
                - 어떤 인터럽트 서비스 루틴을 사용할지 식별하기 위한 정보
            - 인터럽트 서비스 루틴(인터럽트 핸들러)
                - 인터럽트를 처리하기 위해 실행하는 프로그램
        6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해 둔 작업을 복구하여 실행을 재개한다.